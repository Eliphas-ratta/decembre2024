-- MySQL Script generated by MySQL Workbench
-- Thu Dec 12 00:38:15 2024
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';

-- -----------------------------------------------------
-- Schema ecommerce
-- -----------------------------------------------------

-- -----------------------------------------------------
-- Schema ecommerce
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `ecommerce` DEFAULT CHARACTER SET utf8 ;
USE `ecommerce` ;

-- -----------------------------------------------------
-- Table `ecommerce`.`user`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `ecommerce`.`user` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(20) NOT NULL,
  `email` VARCHAR(100) NOT NULL,
  `password` VARCHAR(45) NOT NULL,
  `created_at` DATE NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE INDEX `id_UNIQUE` (`id` ASC) VISIBLE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `ecommerce`.`order`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `ecommerce`.`order` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `order_date` DATE NOT NULL,
  `total_price` DECIMAL(10,2) NOT NULL,
  `status` VARCHAR(30) NOT NULL,
  `user_id` INT NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `fk_order_user_idx` (`user_id` ASC) VISIBLE,
  CONSTRAINT `fk_order_user`
    FOREIGN KEY (`user_id`)
    REFERENCES `ecommerce`.`user` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `ecommerce`.`product`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `ecommerce`.`product` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(45) NOT NULL,
  `price` DECIMAL(9,2) NOT NULL,
  `stock_quantity` INT NOT NULL,
  `category` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `ecommerce`.`order_details`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `ecommerce`.`order_details` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `quantity` INT NOT NULL,
  `subtotal` DECIMAL(9,2) NOT NULL,
  `order_id` INT NOT NULL,
  `product_id` INT NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `fk_order_details_order1_idx` (`order_id` ASC) VISIBLE,
  INDEX `fk_order_details_product1_idx` (`product_id` ASC) VISIBLE,
  CONSTRAINT `fk_order_details_order1`
    FOREIGN KEY (`order_id`)
    REFERENCES `ecommerce`.`order` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_order_details_product1`
    FOREIGN KEY (`product_id`)
    REFERENCES `ecommerce`.`product` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;


--SI tu veux un id qui automatique fait 1 2 3 etc enlever id 

INSERT INTO user (id, name, email, password, created_at) VALUES
(1, 'Alice', 'alice@example.com', 'password123', '2024-01-01'),
(2, 'Bob', 'bob@example.com', 'securepass', '2024-02-01');



INSERT INTO products (id, name, price, stock_quantity, category) VALUES
(1, 'Laptop', 999.99, 10, 'Electronics'),
(2, 'Headphones', 49.99, 50, 'Accessories');



INSERT INTO `order` (id, user_id, order_date, total_price, status) VALUES
(1, 1, '2024-03-01', 1099.98, 'Completed'),
(2, 2, '2024-03-05', 49.99, 'Pending');



INSERT INTO order_details (id, order_id, product_id, quantity, subtotal) VALUES
(1, 1, 1, 1, 999.99),
(2, 1, 2, 2, 99.98);

-- 6. Les contraintes 

--1. Ajoutez une contrainte UNIQUE sur la colonne `email` de la table `users`.

ALTER TABLE users ADD UNIQUE(email);


--2. Ajoutez une contrainte de clé étrangère entre `user_id` de `orders` et `id` de `users`.

ALTER TABLE orders ADD CONTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id);

--3. Assurez-vous que la quantité dans `order_details` ne peut pas être négative.

ALTER TABLE order_details MODIFY quantityINT CHECK (quantity >= 0);

-- 7. Les Jointures

--1. Affichez tous les détails des commandes, avec le nom du produit et l'email de l'utilisateur.

SELECT od.id, od.orders_id, p.name, u.email FROM order_details order_date
INNER JOIN products p ON p;id = od.products_id
INNER JOIN orders o ON o.id = od.orders_id
INNER JOIN users u ON u.id = o.users_id;

--2. Affichez le total dépensé par chaque utilisateur.

SELECT SUM(o.total_price) AS montant_total
FROM orders od
INNER JOIN users u ON o.users_id = u.id
GROUP BY o.users_id;


--3. Trouvez tous les produits jamais commandés.

Select * FROM products WHERE id NOT IN (SELECT id FROM order_details);


-- 8. Transactions et procédures (15 min)


--1. Implémentez une transaction qui :

--   - Insère une nouvelle commande pour un utilisateur.
START TRANSACTION;
INSERT INTO orders VALUE ('2012-12-16', 99, 'Pending', 2);
--   - Met à jour le stock du produit commandé.
SET @product_id = 1;
SET @quantity = 2

SELECT stock_quantity INTO @current stock
FROM products
WHERE id = @product_id
--   - Annule la transaction si le stock est insuffisant.
IF @current_stock >= @quantity THEN 
    UPDATE products
    SET stock_quantity = stock_quantity = @quantity
    WHERE id = @product_id

-- Confirmer la transaction 
    COMMIT;
ELSE
-- Annuler la transaction si le stock est insuffisant
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = CONCAT('STOCK insuffisant pour ce produit', @product_id)
    ROLLBACK;
END IF;



--2. Créez une procédure stockée pour ajouter un produit et vérifier automatiquement la catégorie.

-- PROCÉDURE STOCKÉE

-- PROCÉDURE STOCKÉE

DELIMITER //

CREATE PROCEDURE create_order_and_update_stock(
    IN user_id INT,
    IN product_id INT,
    IN quantity INT
)
BEGIN
    DECLARE current_stock INT;
    DECLARE new_order_id INT;
    DECLARE product_price DECIMAL(10,2);
    DECLARE total_price DECIMAL(10,2);

    START TRANSACTION;

    -- 1. Récupérer le stock actuel et le prix du produit
    SELECT stock_quantity, price
    INTO current_stock, product_price
    FROM products
    WHERE id = product_id;

    -- 2. Vérifier si le stock est suffisant
    IF current_stock >= quantity THEN

        -- Calculer le prix total
        SET total_price = product_price * quantity;

        -- 3. Insérer la commande dans 'orders'
        INSERT INTO orders (user_id, order_date, total_price, status)
        VALUES (user_id, NOW(), total_price, 'Pending');

        -- Récupérer l'ID de la commande créée
        SET new_order_id = LAST_INSERT_ID();

        -- 4. Mettre à jour le stock du produit
        UPDATE products
        SET stock_quantity = stock_quantity - quantity
        WHERE id = product_id;

        -- 5. Insérer les détails de la commande
        INSERT INTO order_details (order_id, product_id, quantity, subtotal)
        VALUES (new_order_id, product_id, quantity, total_price);

        -- 6. Valider la transaction
        COMMIT;

    ELSE
        -- 7. Envoyer un message d'erreur
        SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'STOCK insuffisant pour ce produit';
    END IF;

END //


DELIMITER ;


--9. Fonction, variables, tables temporaires et vue (20 min)

--1. Créer une fonction utilisateur :
--Écrivez une fonction appelée `get_user_orders` qui prend l'ID d'un utilisateur en paramètre et retourne tous les détails des commandes passées par cet utilisateur.
   

DELIMITER //

  CREATE FUNCtiON get_user_orders(userId INT)
  RETURNS TABLE
  RETURN
  SELECT * FROM orders WHERE users_id = userID;

  // DELIMITER;


--2. Utilisation des variables :
--Déclarez une variable pour stocker la quantité totale de produits commandés par un utilisateur spécifique.
   
   SET @user_id = 1;

   SELECT SUM(od.quantity) AS titak_quantity
   FROM orders od
   INNER JOIN order_details od ON od.orders_id = o.id
   WHERE o.users_id = @user_id;
--3. Créer une table temporaire :
  -- Créez une table temporaire pour stocker les produits dont le stock est inférieur à une certaine limite.

 CREATE TEMPORARY TABLE low_stock_products AS
 SELECT * FROM products WHERE stock_quantity < 5;
--4. Créer une vue :
  -- Créez une vue pour afficher les utilisateurs et leur total dépensé sur le site e-commerce.

CREATE VIEW user_spending AS 
SELECT u.name, SUM(o.total_price) AS total_spent
FROM users u
INNER JOIN orders o ON o.users_id = u.id
GROUP BY u.name;